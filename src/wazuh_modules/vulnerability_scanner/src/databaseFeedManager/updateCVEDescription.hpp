/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * Oct 3, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPDATE_CVE_DESCRIPTION_HPP
#define _UPDATE_CVE_DESCRIPTION_HPP

#include "chainOfResponsability.hpp"
#include "cve5_generated.h"
#include "eventContext.hpp"
#include "flatbuffers/flatbuffers.h"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityDescription_generated.h"

constexpr auto DESCRIPTION_DATABASE_PATH {"queue/vd/descriptions"};
constexpr auto CVE5_DATABASE_PATH {"queue/vd/cve5"};

/**
 * @brief UpdateCVEDescription class.
 *
 */
class UpdateCVEDescription final
{
public:
    /**
     * @brief Reads CVE5 database, creates a vulnerability description flatbuffer and stores it in a specific RocksDB
     * database.
     *
     * @param cve5Flatbuffer CVE5 Flatbuffer.
     * @param rocksDBWrapper rocksDB wrapper instance.
     */
    static void storeVulnerabilityDescription(const cve_v5::Entry* cve5Flatbuffer,
                                              Utils::RocksDBWrapper& rocksDBWrapper)
    {
        if (cve5Flatbuffer->containers() && cve5Flatbuffer->containers()->cna())
        {
            auto cna = cve5Flatbuffer->containers()->cna();
            // Missing metrics object is valid in a CVE5 schema.
            auto metricsArray = cna->metrics();
            auto descriptionArray = cna->descriptions();
            auto referencesArray = cna->references();
            auto problemTypesArray = cna->problemTypes();
            auto cve5Metadata = cve5Flatbuffer->cveMetadata();

            float VulnDescFBScoreBase = 0.0;
            std::string VulnDescFBClassificationStr;
            std::string VulnDescFBDescriptionStr;
            std::string VulnDescFBSeverityStr;
            std::string VulnDescFBScoreVersionStr;
            std::string VulnDescFBReferenceStr;
            std::string VulnDescFBAssignerStr;
            std::string VulnDescFBCWEIdStr;
            std::string VulnDescFBDataPublishedStr;
            std::string VulnDescFBDataUpdatedStr;
            std::string VulnDescFBVectorStringStr;

            if (descriptionArray)
            {
                for (const auto& field : *descriptionArray)
                {
                    if (field->lang()->str().compare("en") == 0)
                    {
                        VulnDescFBDescriptionStr = field->value()->str();
                        break;
                    }
                }
            }

            if (referencesArray)
            {
                for (const auto& field : *referencesArray)
                {
                    if (field->url())
                    {
                        VulnDescFBReferenceStr += field->url()->str();
                        VulnDescFBReferenceStr += ", ";
                    }
                }
            }

            VulnDescFBReferenceStr = VulnDescFBReferenceStr.substr(0, VulnDescFBReferenceStr.size() - 2);

            // Empty description or empty URL reference are not CVE5 Compliant.
            if (!(VulnDescFBDescriptionStr.empty() || VulnDescFBReferenceStr.empty()))
            {
                flatbuffers::FlatBufferBuilder builder;

                if (metricsArray)
                {
                    for (const auto& field : *metricsArray)
                    {
                        auto metricCVSSV3_1 = field->cvssV3_1();
                        auto metricCVSSV3_0 = field->cvssV3_0();
                        auto metricCVSSV2_0 = field->cvssV2_0();
                        if (metricCVSSV3_1)
                        {
                            VulnDescFBScoreBase = metricCVSSV3_1->baseScore();
                            auto baseSeverity = metricCVSSV3_1->baseSeverity();
                            VulnDescFBSeverityStr = (nullptr != baseSeverity) ? baseSeverity->str() : "";
                            auto version = metricCVSSV3_1->version();
                            VulnDescFBScoreVersionStr = (nullptr != version) ? version->str() : "";
                            auto format = field->format();
                            VulnDescFBClassificationStr = (nullptr != format) ? format->str() : "";
                            auto vectorString = metricCVSSV3_1->vectorString();
                            VulnDescFBVectorStringStr = (nullptr != vectorString) ? vectorString->str() : "";
                            break;
                        }
                        else if (metricCVSSV3_0)
                        {
                            VulnDescFBScoreBase = metricCVSSV3_0->baseScore();
                            auto baseSeverity = metricCVSSV3_0->baseSeverity();
                            VulnDescFBSeverityStr = (nullptr != baseSeverity) ? baseSeverity->str() : "";
                            auto version = metricCVSSV3_0->version();
                            VulnDescFBScoreVersionStr = (nullptr != version) ? version->str() : "";
                            auto format = field->format();
                            VulnDescFBClassificationStr = (nullptr != format) ? format->str() : "";
                            auto vectorString = metricCVSSV3_0->vectorString();
                            VulnDescFBVectorStringStr = (nullptr != vectorString) ? vectorString->str() : "";
                            break;
                        }
                        else if (metricCVSSV2_0)
                        {
                            VulnDescFBScoreBase = metricCVSSV2_0->baseScore();
                            VulnDescFBSeverityStr = (VulnDescFBScoreBase < 4.0)   ? "LOW"
                                                    : (VulnDescFBScoreBase < 7.0) ? "MEDIUM"
                                                                                  : "HIGH";
                            auto version = metricCVSSV2_0->version();
                            VulnDescFBScoreVersionStr = (nullptr != version) ? version->str() : "";
                            auto format = field->format();
                            VulnDescFBClassificationStr = (nullptr != format) ? format->str() : "";
                            auto vectorString = metricCVSSV2_0->vectorString();
                            VulnDescFBVectorStringStr = (nullptr != vectorString) ? vectorString->str() : "";
                            break;
                        }
                    }
                }

                if (cve5Metadata)
                {
                    auto assigner = cve5Metadata->assignerShortName();
                    VulnDescFBAssignerStr = (nullptr != assigner) ? assigner->str() : "";
                    auto published = cve5Metadata->datePublished();
                    VulnDescFBDataPublishedStr = (nullptr != published) ? published->str() : "";
                    auto updated = cve5Metadata->dateUpdated();
                    VulnDescFBDataUpdatedStr = (nullptr != updated) ? updated->str() : "";
                }

                if (problemTypesArray)
                {
                    auto problemTypesDescriptionsArray = problemTypesArray->Get(0);
                    if (problemTypesDescriptionsArray)
                    {
                        auto descriptionsProblemTypesArray = problemTypesDescriptionsArray->descriptions();
                        if (descriptionsProblemTypesArray) {
                            auto cweId = descriptionsProblemTypesArray->Get(0)->cweId();
                            VulnDescFBCWEIdStr = (nullptr != cweId) ? cweId->str() : "";
                        }
                    }
                }

                auto vulnerabilityDescriptionFB =
                    NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(builder,
                                                                                 VulnDescFBAssignerStr.c_str(),
                                                                                 VulnDescFBScoreBase,
                                                                                 VulnDescFBClassificationStr.c_str(),
                                                                                 VulnDescFBCWEIdStr.c_str(),
                                                                                 VulnDescFBDataPublishedStr.c_str(),
                                                                                 VulnDescFBDataUpdatedStr.c_str(),
                                                                                 VulnDescFBDescriptionStr.c_str(),
                                                                                 VulnDescFBSeverityStr.c_str(),
                                                                                 VulnDescFBScoreVersionStr.c_str(),
                                                                                 VulnDescFBReferenceStr.c_str(),
                                                                                 VulnDescFBVectorStringStr.c_str());

                builder.Finish(vulnerabilityDescriptionFB);

                const uint8_t* buffer = builder.GetBufferPointer();
                size_t flatbufferSize = builder.GetSize();

                std::string key {cve5Flatbuffer->cveMetadata()->cveId()->str()};
                const rocksdb::Slice VulnerabilityDescriptionSlice(reinterpret_cast<const char*>(buffer),
                                                                   flatbufferSize);
                rocksDBWrapper.put(key, VulnerabilityDescriptionSlice);
            }
        }
    }
};

#endif // _UPDATE_CVE_DESCRIPTION_HPP
