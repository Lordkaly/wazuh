/*
 * Wazuh databaseFeedManager
 * Copyright (C) 2015, Wazuh Inc.
 * November 22, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "sendReport_test.hpp"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_synchronization_generated.h"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_synchronization_schema.h"
#include "../scanOrchestrator/sendReport.hpp"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "flatbuffers/util.h"
#include "socketClient.hpp"
#include "socketServer.hpp"

const std::string TEST_PATH {"/tmp/socket"};
const size_t MAX_RETRIES {10};

const std::string SYNC_MSG =
    R"(
            {
                "agent_info": {
                    "agent_id": "001",
                    "agent_ip": "192.168.33.20",
                    "agent_name": "focal",
                    "node_name": "node01"
                },
                "data_type": "state",
                "data": {
                    "attributes_type": "syscollector_packages",
                    "attributes": {
                        "architecture": " ",
                        "checksum": "d24e16553ac8f6983f16fb7a68b841ac8876d745",
                        "description": " ",
                        "format": "pypi",
                        "groups": " ",
                        "install_time": " ",
                        "item_id": "e051a99ad3950084b538c6538c0fcad0f1c4c713",
                        "location": "/usr/lib/python3/dist-packages/language_selector-0.1.egg-info/PKG-INFO",
                        "name": "language-selector",
                        "priority": " ",
                        "scan_time": "2023/12/01 20:48:21",
                        "size": 0,
                        "source": " ",
                        "vendor": " ",
                         "version": "0.1"
                    },
                    "index": "e051a99ad3950084b538c6538c0fcad0f1c4c713",
                    "timestamp": ""
                }
            }
        )";
const std::string DETECTION_STR =
    R"(
        {
            "vulnerability": {
                "category": "Packages",
                "classification": "CVSS",
                "cve": "CVE-2020-14343",
                "description": "A vulnerability was discovered in the PyYAML library in versions before 5.4, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. This flaw allows an attacker to execute arbitrary code on the system by abusing the python/object/new constructor. This flaw is due to an incomplete fix for CVE-2020-1747.",
                "enumeration": "CVE",
                "package": {
                    "architecture": " ",
                    "build_version": "",
                    "checksum": "",
                    "description": " ",
                    "install_scope": "",
                    "install_time": " ",
                    "license": "",
                    "name": "PyYAML",
                    "path": "/usr/lib/python3/dist-packages/PyYAML-5.3.1.egg-info",
                    "reference": "",
                    "size": 0,
                    "type": "pypi",
                    "version": "5.3.1"
                },
                "reference": "https://bugzilla.redhat.com/show_bug.cgi?id=1860466, https://github.com/SeldonIO/seldon-core/issues/2252, https://github.com/yaml/pyyaml/issues/420, https://www.oracle.com/security-alerts/cpuapr2022.html, https://www.oracle.com/security-alerts/cpujul2022.html",
                "score": {
                    "base": 9.800000190734863,
                    "environmental": 0.0,
                    "temporal": 0.0,
                    "version": "3.1"
                },
                "severity": "Critical",
                "status": "Active"
            }
        }
    )";

TEST_F(SendReportTest, SendFormattedMsg)
{
    const std::string report =
        R"({"vulnerability":{"category":"Packages","classification":"CVSS","cve":"CVE-2020-14343","description":"A vulnerability was discovered in the PyYAML library in versions before 5.4, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. This flaw allows an attacker to execute arbitrary code on the system by abusing the python/object/new constructor. This flaw is due to an incomplete fix for CVE-2020-1747.","enumeration":"CVE","package":{"architecture":" ","build_version":"","checksum":"","description":" ","install_scope":"","install_time":" ","license":"","name":"PyYAML","path":"/usr/lib/python3/dist-packages/PyYAML-5.3.1.egg-info","reference":"","size":0,"type":"pypi","version":"5.3.1"},"reference":"https://bugzilla.redhat.com/show_bug.cgi?id=1860466, https://github.com/SeldonIO/seldon-core/issues/2252, https://github.com/yaml/pyyaml/issues/420, https://www.oracle.com/security-alerts/cpuapr2022.html, https://www.oracle.com/security-alerts/cpujul2022.html","score":{"base":9.800000190734863,"environmental":0.0,"temporal":0.0,"version":"3.1"},"severity":"Critical","status":"Active"}})";
    std::string expectedStr = "1:[001] (focal) 192.168.33.20->vulnerability-scanner:" + report;

    // Fake socket server
    auto thread = std::thread(
        [&]()
        {
            struct sockaddr_un serverAddr
            {
            };
            struct sockaddr_un clientAddr
            {
            };

            int socketServer = socket(AF_UNIX, SOCK_DGRAM, 0);
            ASSERT_NE(socketServer, -1);

            serverAddr.sun_family = AF_UNIX;
            std::strcpy(serverAddr.sun_path, TEST_PATH.c_str());

            ASSERT_NE(bind(socketServer, (struct sockaddr*)&serverAddr, sizeof(serverAddr)), -1);

            char buffer[65536];
            size_t bytesReceived;
            socklen_t clientSize = sizeof(clientAddr);

            bytesReceived =
                recvfrom(socketServer, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &clientSize);

            ASSERT_NE(bytesReceived, -1);
            buffer[bytesReceived] = '\0';

            EXPECT_STREQ(buffer, expectedStr.c_str());

            close(socketServer);
            std::filesystem::remove(TEST_PATH);
        });

    // Socket client instance.
    std::shared_ptr<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>> socketClient =
        std::make_shared<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>>(TEST_PATH);

    // Wait for server.
    struct stat fileStat
    {
    };
    int statRet;
    size_t retries = 0;
    do
    {
        ++retries;
        std::this_thread::sleep_for(std::chrono::milliseconds(100 * retries));
        statRet = stat(TEST_PATH.c_str(), &fileStat);
    } while (statRet != 0 && retries < MAX_RETRIES);

    // Connect to server.
    socketClient->connect(
        [](const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader) {}, []() {}, SOCK_DGRAM);

    // Send report instance.
    SendReport sendReport(socketClient);

    // Mock scanContext.
    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_synchronization_SCHEMA));
    ASSERT_TRUE(parser.Parse(SYNC_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> syscollectorSync =
        SyscollectorSynchronization::GetSyncMsg(reinterpret_cast<const char*>(buffer));
    auto scanContext = std::make_shared<ScanContext>(syscollectorSync);
    nlohmann::json detectionJson = nlohmann::json::parse(DETECTION_STR);
    scanContext->m_alerts["CVE-2020-14343"] = detectionJson;

    // Send report.
    sendReport.handleRequest(scanContext);

    thread.join();
}

TEST_F(SendReportTest, InvalidEncodingValue)
{
    std::string expectedString {"Message not delivered."};

    // Fake socket server
    auto thread = std::thread(
        [&]()
        {
            struct sockaddr_un serverAddr
            {
            };
            struct sockaddr_un clientAddr
            {
            };

            int socketServer = socket(AF_UNIX, SOCK_DGRAM, 0);
            ASSERT_NE(socketServer, -1);

            serverAddr.sun_family = AF_UNIX;
            std::strcpy(serverAddr.sun_path, TEST_PATH.c_str());

            ASSERT_NE(bind(socketServer, (struct sockaddr*)&serverAddr, sizeof(serverAddr)), -1);

            char buffer[1024];
            size_t bytesReceived;
            socklen_t clientSize = sizeof(clientAddr);

            bytesReceived =
                recvfrom(socketServer, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &clientSize);

            ASSERT_NE(bytesReceived, -1);
            buffer[bytesReceived] = '\0';

            EXPECT_STREQ(buffer, expectedString.c_str());

            close(socketServer);
            std::filesystem::remove(TEST_PATH);
        });

    nlohmann::json reportJson;
    nlohmann::json packageObject;
    packageObject["name"] = "\xAA";
    reportJson["vulnerability"] = packageObject;

    // Socket client instance.
    std::shared_ptr<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>> socketClient =
        std::make_shared<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>>(TEST_PATH);

    // Wait for server.
    struct stat fileStat
    {
    };
    int statRet;
    size_t retries = 0;
    do
    {
        ++retries;
        std::this_thread::sleep_for(std::chrono::milliseconds(100 * retries));
        statRet = stat(TEST_PATH.c_str(), &fileStat);
    } while (statRet != 0 && retries < MAX_RETRIES);

    // Connect to server.
    socketClient->connect(
        [](const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader) {}, []() {}, SOCK_DGRAM);

    // Send report instance.
    SendReport sendReport(socketClient);

    // Mock scanContext.
    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_synchronization_SCHEMA));
    ASSERT_TRUE(parser.Parse(SYNC_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> syscollectorSync =
        SyscollectorSynchronization::GetSyncMsg(reinterpret_cast<const char*>(buffer));
    auto scanContext = std::make_shared<ScanContext>(syscollectorSync);
    nlohmann::json detectionJson = nlohmann::json::parse(DETECTION_STR);
    detectionJson["data"]["package"]["name"] = "\xAA";
    scanContext->m_alerts["CVE-2020-14343"] = detectionJson;

    // Send report.
    sendReport.handleRequest(scanContext);

    // The report was not sent. A dummy message is sent to close the server socket.
    send(socketClient->getSocketDescriptor(), expectedString.c_str(), expectedString.size(), 0);

    thread.join();
}
